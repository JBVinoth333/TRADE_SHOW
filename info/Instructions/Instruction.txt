DATA GENERATION FRAMEWORK - INSTRUCTIONS & RULES

OVERVIEW
• Generates test data from OpenAPI specifications
• Define generator rules once, apply consistently across all parameters
• Ensures reliable, reusable, and maintainable test data creation
• All generators must follow mandatory rules for compliance

SECTION 1: CORE RULES FOR ALL GENERATORS

THREE MANDATORY RULES
1. SPECIFY TYPE
   Required: "type" property in every generator
   Valid types: dynamic, remote, static, reference, conditional
   Example: { "type": "static", "value": "OPEN" }

2. USE ARRAYS
   Required: [ ] brackets around each generator (even single generators)
   Correct: "status": [ { "type": "static", "value": "OPEN" } ]
   Wrong: "status": { "type": "static", "value": "OPEN" }

3. USE SNAKE_CASE NAMING
   Required: lowercase_with_underscores format
   IDs must end with "_id" suffix
   Examples: agent_id, ticket_status, created_timestamp

NAMING CONVENTIONS

Pattern Examples:
  agent_id - Any agent ID
  active_agent_id - Agent with ACTIVE status
  created_ticket_id - Result of ticket creation
  
Guidelines:
  • Base entity name first (agent_id, ticket_id)
  • Add status/filter if applicable (active_agent_id, open_ticket_id)
  • Add operation if applicable (created_ticket_id, updated_contact_id)
  • Avoid vague names (id1, data, temp, var)
  • Ensure consistency across all entity files

GENERATOR REFERENCES

Same File Reference:
  Format: "#/generators/generator_name"
  Example: "agentId": "#/generators/agent_id"

Different File Reference:
  Format: "../EntityName/test_data_generation_configurations.json#/generators/name"
  Example: "agentId": "../Agent/test_data_generation_configurations.json#/generators/agent_id"

Array Parameters (Multiple Values):
  Format: "parameterName[*]": "#/generators/name"
  Example: "agentIds[*]": "#/generators/agent_id"
  Meaning: Use multiple values from this generator

JSONPATH FORMAT

Format: $.location:$.path

Locations:
  $.response.body - API response body JSON
  $.input.body - Request body JSON
  $.input.query - Query string parameters
  $.input.path - URL path parameters
  $.input.header - HTTP request headers

Common Patterns:
  $.data[*].id - All IDs from array
  $.data[0].id - First element only
  $.manager.id - Nested object field
  $.parent.child.id - Deep nesting

SECTION 2: GENERATOR TYPES & RULES

FIVE GENERATOR TYPES
| Type | Purpose | When to Use | Complexity |
|------|---------|-------------|------------|
| DYNAMIC | Fetch IDs from APIs | Need actual system data | Medium |
| REMOTE | System functions | Timestamps, enums, config | Medium |
| STATIC | Fixed constant values | Value never changes | Low |
| REFERENCE | Use request input | Pass-through from request | Low |
| CONDITIONAL | Logic-based branching | Value depends on conditions | High |

TYPE 1: DYNAMIC - FETCH FROM API RESPONSES

Required Properties:
  type - String "dynamic"
  generatorOperationId - API operation to call
  dataPath - Where to extract data in response (Format: $.response.body:$.path.to.data)

Optional Properties:
  params - Filter parameters (e.g., {"status": "ACTIVE"})
  name - Generator identifier

Rules:
1. Always specify which API operation to call
2. Use dataPath to select exact data from response
3. Use [*] for all array elements, [0] for first only
4. Use params to filter API results
5. Test the API call manually first

Example:
{
  "type": "dynamic",
  "generatorOperationId": "support.Agent.getAgents",
  "dataPath": "$.response.body:$.data[*].id",
  "params": {"status": "ACTIVE"}
}

TYPE 2: REMOTE - CALL SYSTEM FUNCTIONS

Required Properties:
  type - String "remote"
  generatorMethod - System function to call
  inputs - Function parameters

Optional Properties:
  name - Generator identifier

Rules:
1. Always provide format parameter for timestamps
2. Use appropriate timeLine value: current, future, past
3. Include orgId when system requires it
4. Use UTC timezone (Z suffix)
5. Verify field names against OpenAPI spec

Common System Methods:
  getDateTime - Generate timestamps
    Parameters: timeLine (current/future/past), format
  
  getDynamicEnumValues - Get enumeration values
    Parameters: fieldName, moduleName, orgId
  
  getCustomFieldSchema - Get field structure
    Parameters: fieldType, schemaName

Timestamp Format: yyyy-MM-dd'T'HH:mm:ss.SSS'Z'
  yyyy=Year, MM=Month, dd=Day, HH=Hour, mm=Minute, ss=Second, SSS=Milliseconds

Timeline Values:
  current - Right now (use for: creation timestamps)
  future - Later (use for: deadlines, expiry dates)
  past - Earlier (use for: historical data)

Example:
{
  "type": "remote",
  "generatorMethod": "applicationDriver.rpc.desk.DynamicDataProvider.getDateTime",
  "inputs": {
    "timeLine": "current",
    "format": "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
  }
}

TYPE 3: REFERENCE - USE REQUEST INPUT DATA

Required Properties:
  type - String "reference"
  ref - Path to request data (Format: $.input.{location}:$.{path})

Optional Properties:
  name - Generator identifier

Rules:
1. Verify field exists in request before using
2. Use exact field names (case-sensitive)
3. Use correct location (body, query, path, header)
4. Document expected request structure
5. Test with real request samples

Reference Locations:
  $.input.body - Request body JSON
  $.input.query - Query parameters
  $.input.path - URL path parameters
  $.input.header - HTTP headers

Example:
{
  "type": "reference",
  "ref": "$.input.body:$.ticketId"
}

TYPE 4: STATIC - FIXED HARDCODED VALUES

Required Properties:
  type - String "static"
  value - The constant value (any JSON type)

Optional Properties:
  name - Generator identifier

Rules:
1. Use only for truly fixed values
2. Match value type to OpenAPI specification
3. For changing values, use DYNAMIC instead
4. For timestamps, use REMOTE instead
5. Create variants for different test scenarios

Supported Value Types:
  String - Quoted text ("OPEN", "HIGH")
  Number - No quotes (42, 99, -5)
  Decimal - No quotes (99.99, 3.14)
  Boolean - true or false
  Array - [ ] brackets (["a", "b"], [1, 2])
  Object - { } braces ({"field": "value"})
  Null - null keyword

Example:
{
  "type": "static",
  "value": "OPEN"
}

TYPE 5: CONDITIONAL - LOGIC-BASED VALUES

Required Properties:
  type - String "conditional"
  condition - Condition to evaluate (Format: field == 'value')
  then - Generator to use if true

Optional Properties:
  else - Generator if false (defaults to null)
  name - Generator identifier

Condition Format Rules:
  • Use field name on left side
  • Use == operator (equality only)
  • Quote string values: 'VALUE'
  • No quotes for booleans or numbers
  • Examples: priority == 'HIGH', isClosed == true, severity == 'CRITICAL'

Rules:
1. Keep conditions simple and readable
2. Provide both then and else branches when possible
3. Limit nesting to 2-3 levels maximum
4. Test all branches in each condition
5. Field names reference input or other generators

Branch Types (Then/Else can use any):
  • Static (fixed value)
  • Dynamic (fetch from API)
  • Remote (system function)
  • Reference (request data)
  • Conditional (nested)

Example:
{
  "type": "conditional",
  "condition": "priority == 'HIGH'",
  "then": {"type": "static", "value": "ESCALATED"},
  "else": {"type": "static", "value": "NORMAL"}
}

SECTION 3: REAL-WORLD PATTERNS & EXAMPLES

ENTITY RELATIONSHIPS

Account (Root)
  ├─ Department
  ├─ Contact
  └─ Contract

Agent
  ├─ Department
  └─ Used in: Ticket, Call, Activity

Ticket
  ├─ Contact
  ├─ Agent
  └─ Department

Contact
  └─ Account

When creating generators, reference related entities using cross-file references.

TESTING SCENARIOS

Success Cases (200/201 response):
  • "valid_ticket_id" → from DYNAMIC (actual data)
  • "valid_status" → from STATIC ("OPEN")

Error Cases (404/422 response):
  • "invalid_ticket_id" → from STATIC (99999)
  • "invalid_status" → from STATIC ("INVALID_STATUS")

Edge Cases:
  • Null values
  • Empty arrays
  • Boundary values

MULTIPLE VALUES & DUAL FIELDS

Array Parameters:
  Format: "parameterName[*]": "#/generators/name"
  Example: "agentIds[*]": "#/generators/agent_id"

Dual Field Handling (cf and customFields are equivalent):
  "cf": [{"type": "static", "value": {"field_100": "value"}}]
  "custom_fields": [{"type": "static", "value": {"field_100": "value"}}]

SECTION 4: VALIDATION CHECKLIST

Before committing your generator file, verify:

STRUCTURE VALIDATION
  ✓ JSON is valid (no trailing commas, all brackets closed)
  ✓ Only root key is "generators"
  ✓ All generators wrapped in arrays [ ]

GENERATOR VALIDATION
  ✓ Every generator has required "type" property
  ✓ All required properties present for each type
  ✓ Property names spelled correctly (case-sensitive)
  ✓ JSON values have correct syntax

NAMING VALIDATION
  ✓ All names are lowercase with underscores (snake_case)
  ✓ IDs end with _id
  ✓ Names are descriptive
  ✓ No camelCase or UPPERCASE

REFERENCE VALIDATION
  ✓ Same-file refs use: #/generators/name
  ✓ Cross-file refs use: ../Entity/file.json#/generators/name
  ✓ All referenced generators exist
  ✓ All referenced files exist

TESTING VALIDATION
  ✓ Manually verify one example works
  ✓ Data types match OpenAPI expectations
  ✓ Values match actual API response format

SECTION 5: KEY PRINCIPLES

CONSISTENCY
  • Use same rules everywhere
  • Follow same patterns across all generator files
  • Apply same validation rules
  • Organize files similarly

REUSABILITY
  • Define generators once, reference many times
  • Reduces duplication and errors
  • Easier to update values
  • Simplifies maintenance

CLARITY
  • Use descriptive names showing purpose
  • Names show entity being referenced
  • Names show status or filter applied
  • Self-documenting code

VALIDATION
  • Always verify before committing
  • JSON syntax is valid
  • All references exist
  • Field names match OpenAPI
  • Generator properties are correct

SECTION 6: QUICK REFERENCE

GENERATOR TYPES SUMMARY
DYNAMIC - type, generatorOperationId, dataPath
REMOTE - type, generatorMethod, inputs
REFERENCE - type, ref
STATIC - type, value
CONDITIONAL - type, condition, then (else optional)

CORE RULES (MANDATORY)
1. Include "type" in every generator
2. Wrap all generators in arrays []
3. Use snake_case naming with "_id" suffix for IDs
4. Use [*] suffix for array parameters
5. Use ../ for cross-file references
6. Match value types to OpenAPI spec

IMPORTANT FILE RESTRICTIONS
NEVER edit in existing entities:
  • OpenAPI Specification (OAS) files
  • Generator files (test_data_generation_configurations.json)

These are auto-generated or system-controlled.
Use proper configuration management for changes.

WORKFLOW STEPS
1. Analyze OpenAPI specification
2. Identify required vs optional parameters
3. Choose appropriate generator types
4. Create generators with descriptive names
5. Validate JSON syntax
6. Test with sample data
7. Verify all references exist
8. Get peer review
9. Commit to repository

Last Updated: 12 February 2026
